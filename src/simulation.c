/*
 * GQRM
 * Copyright (C) 2019-2025 Chaofan Ma <chaofanma@hotmail.com>
 *
 * This file is part of GQRM.
 *
 * GQRM is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * GQRM is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with GQRM.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "simulation.h"

static const int   tx_delay = 20;

typedef struct {
    gqrm_id_t      src;
	gqrm_id_t      current;
	gqrm_id_t      next;
	int            start;
	int            end;
	size_t         id;
} packet;

typedef struct {
    int       trigger_time;
	packet*   pkt;
} event, *p_event;

static const int back[8] = {1, 2, 4, 8, 16, 32, 64, 128};

static p_event
create_event(packet* pkt, int trigger)
{
    p_event pe;
	if (!pkt)
	    return NULL;
	if ((pe = malloc(sizeof(event))) == NULL)
	    return NULL;
	pe->pkt = pkt;
	pe->trigger_time = trigger;
	return pe;
}

static ds_bool
check_collision(p_event run[], size_t n, p_event wait)
{
    size_t       i;

	for (i = 0; i < n; i++)
	    if (wait->pkt->next == run[i]->pkt->next)
		    return DS_TRUE;
	return DS_FALSE;
}

static void
backoff(p_event wait)
{
    wait->trigger_time += back[rand() % 8];
}

double
simulate(pt_ALGraph pg, gqrm_id_t src, gqrm_id_t dsts[], size_t n)
{
    packet       pkts[n];
	p_event      run[n], wait[n];
	size_t       run_size, wait_size, i, j;
	size_t       clk = 0;
	pt_Vertex    pv;
	size_t       col = 0;
	gqrm_id_t    parent;
	double       statistic = 0.0;

    printf("func: %s, line: %d\n", __func__, __LINE__);
    /* generate n packets */
	for (i = 0; i < n; i++) {
	    pv = NULL;
	    if (ALGraph_GetVertexByID(pg, dsts[i], &pv) == DS_ERROR)
		    return -1.0;
		assert(pv);
		Vertex_GetParent(pv, &parent);
		pkts[i].src     = dsts[i];
		pkts[i].current = dsts[i];
		pkts[i].next    = parent;
		pkts[i].start   = 0;
		pkts[i].end     = 0;
		pkts[i].id      = i;
	}
    printf("func: %s, line: %d\n", __func__, __LINE__);
	/* make n waiting event */
    for (i = 0; i < n; i++) {
	    wait[i] = create_event(&pkts[i], 0);
		pkts[i].start = 0;
	}
	wait_size = n; run_size = 0;

    printf("func: %s, line: %d\n", __func__, __LINE__);
	while (wait_size || run_size) { 
        printf("func: %s, line: %d\n", __func__, __LINE__);
	    /* check each waiting event */
	    for (i = 0; i < wait_size; ) {
		    /* if an event meets its trigger time */
		    if (clk == wait[i]->trigger_time) {
			    /* if collsion free for this event */
		        if (check_collision(run, run_size, wait[i]) == DS_FALSE) {
				    /* move this event to running event list */
		    	    run[run_size++] = wait[i];
	    			wait_size--;
    				for (j = i; j < wait_size; j++)
				        wait[j] = wait[j + 1];
				/* if collosion happens */
			    } else {
				   /* backoff */
				   col++;
		    	    backoff(wait[i++]);
	    		}
    		} else {
			    i++;
			}
		}
        printf("func: %s, line: %d\n", __func__, __LINE__);
        /* check each running event */
		for (i = 0; i < run_size;) {
		    /* if a running event has expired */
		    if (clk > run[i]->trigger_time + tx_delay) {
			    /* 
				 * if this expired event is to transmit a packet
				 * to the destination, there will be no new event
				 * generated by this event. Otherwise, a new event
				 * will be generated and put into the waiting event
				 * list.
				 */
			    if (run[i]->pkt->next != -1) {
				    pv = NULL;
				    ALGraph_GetVertexByID(pg, run[i]->pkt->next, &pv);
					assert(pv);
					Vertex_GetParent(pv, &parent);
					run[i]->pkt->current = run[i]->pkt->next;
					run[i]->pkt->next    = parent;
					wait[wait_size++] == create_event(run[i]->pkt, clk + 1);
				}
				run[i]->pkt->end = clk;
				/* delete this expired event */
				free(run[i]);
				run_size--;
				for (j = i; j < run_size; j++)
				    run[j] = run[j + 1];
			} else {
			    i++;
			}
		}
		clk++;
	}
	for (i = 0; i < n; i++)
	    statistic += pkts[i].end;
	printf("collision %ld\n", col);
	return statistic / n;
}
